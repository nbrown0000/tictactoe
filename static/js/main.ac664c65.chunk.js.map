{"version":3,"sources":["App.js","serviceWorker.js","index.js"],"names":["Game","props","computersMove","state","computerSymbol","grid","possibleMoves","length","availGoodMoves","intersection","chosenGoodMove","Math","floor","random","playMove","setState","turn","columnToDefend","console","log","rowToDefend","leftDiagToDefend","rightDiagToDefend","moves","chosenMove","gameOver","playerSymbol","time","Promise","resolve","setTimeout","this","event","map","item","i","forEach","push","some","r","includes","arr1","arr2","result","symbol","positionsTakenBy","position","className","key","onClick","cellClicked","React","Component","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.ac664c65.chunk.js","sourcesContent":["import React from 'react';\nimport './App.css';\n\nclass Game extends React.Component {\n  constructor(props) {\n    super(props)\n    this.state = {\n      gameOver: false,\n      grid: ['','','','','','','','',''],\n      playerSymbol: 'X',\n      computerSymbol: 'O',\n      turn: 'player'\n    }\n  }\n  \n  sleep(time) {\n    return new Promise((resolve) => setTimeout(resolve, time));\n  }\n\n  componentDidUpdate() {\n    if(this.state.turn === 'computer') this.computersMove();\n  }\n\n  cellClicked(event) {\n    this.setState({grid: this.state.grid.map((item,i) => {\n      if(event===i) {\n        if(this.state.grid[i]==='') { item='X'; this.setState({turn: 'computer'})}\n        if(this.state.grid[i]==='X') { item='X'; this.setState({turn: 'player'})}\n        if(this.state.grid[i]==='O') { item='O'; this.setState({turn: 'player'})}\n      }\n      return item;\n    })})\n  }\n\n  possibleMoves() {\n    var moves = [];\n    this.state.grid.forEach((item,i) => {if(item==='') moves.push(i)})\n    return moves;\n  }\n\n  cornerMovesAvailable() {\n    // if cell 1,3,7,9 available return true\n    if(this.possibleMoves().some(r => [0,2,6,8].includes(r))) return true\n    // else return false\n    else return false\n  }\n\n  intersection(arr1, arr2) {\n    var result = [];\n    arr1.forEach(item => {\n      if(arr2.includes(item)) result.push(item)\n    })\n    return result;\n  }\n\n  positionsTakenBy(symbol) {\n    var result = [];\n    this.state.grid.forEach((item,i) => {\n      if(item===symbol) result.push(i)\n    })\n    return result;\n  }\n\n\n\n  columnToDefend() {\n    const { playerSymbol, computerSymbol } = this.state;\n    if(this.intersection(this.positionsTakenBy(playerSymbol),[0,3,6]).length===2) {\n      if(this.intersection(this.positionsTakenBy(computerSymbol),[0,3,6]).length===0) {\n        return 1\n      }\n    }\n    else if(this.intersection(this.positionsTakenBy(playerSymbol),[1,4,7]).length===2) {\n      if(this.intersection(this.positionsTakenBy(computerSymbol),[1,4,7]).length===0) {\n        return 2\n      }\n    }\n    else if(this.intersection(this.positionsTakenBy(playerSymbol),[2,5,8]).length===2) {\n      if(this.intersection(this.positionsTakenBy(computerSymbol),[2,5,8]).length===0) {\n        return 3\n      }\n    }\n    else return 0\n  }\n\n  rowToDefend() {\n    const { playerSymbol, computerSymbol } = this.state;\n    if(this.intersection(this.positionsTakenBy(playerSymbol),[0,1,2]).length===2) {\n      if(this.intersection(this.positionsTakenBy(computerSymbol),[0,1,2]).length===0) {\n        return 1\n      }\n    }\n    if(this.intersection(this.positionsTakenBy(playerSymbol),[3,4,5]).length===2) {\n      if(this.intersection(this.positionsTakenBy(computerSymbol),[3,4,5]).length===0) {\n        return 2\n      }\n    }\n    if(this.intersection(this.positionsTakenBy(playerSymbol),[6,7,8]).length===2) {\n      if(this.intersection(this.positionsTakenBy(computerSymbol),[6,7,8]).length===0) {\n        return 3\n      }\n    }\n  }\n\n  leftDiagToDefend() {\n    const { playerSymbol, computerSymbol } = this.state;\n    if(this.intersection(this.positionsTakenBy(playerSymbol),[0,4,8]).length===2) {\n      if(this.intersection(this.positionsTakenBy(computerSymbol),[0,4,8]).length===0) {\n        return true\n      }\n    }\n    else return false\n  }\n\n  rightDiagToDefend() {\n    const { playerSymbol, computerSymbol } = this.state;\n    if(this.intersection(this.positionsTakenBy(playerSymbol),[2,4,6]).length===2) {\n      if(this.intersection(this.positionsTakenBy(computerSymbol),[2,4,6]).length===0) {\n        return true\n      }\n    }\n    else return false\n  }\n\n  playMove(position, symbol) {\n    this.setState({grid: this.state.grid.map((item,i) => {\n      if(i===position) item=symbol;\n      return item\n    })})\n\n    const { grid, playerSymbol, computerSymbol } = this.state;\n    if(grid[0]===playerSymbol && grid[4]===playerSymbol && grid[8]===playerSymbol) {\n      this.setState({gameOver: true})\n    }\n\n    \n  }\n\n  //computers turn algorithm\n  computersMove = () => {\n    const { computerSymbol, grid } = this.state\n\n    // sleep(300).then(()=>{\n\n      // Computers First Move\n      if(this.possibleMoves().length===8) {\n        const availGoodMoves = this.intersection(this.possibleMoves(),[0,2,6,8]);\n        const chosenGoodMove = availGoodMoves[Math.floor(Math.random()*availGoodMoves.length)]\n        this.playMove(chosenGoodMove,computerSymbol)\n        this.setState({turn: 'player'})\n      }\n\n      // defend columns\n      else if(this.columnToDefend()) {\n        console.log('Defend a column')\n        switch(this.columnToDefend()) {\n          case 1:\n            // defend column 1\n            if(grid[0]==='') this.playMove(0,computerSymbol)\n            else if(grid[3]==='') this.playMove(3,computerSymbol)\n            else if(grid[6]==='') this.playMove(6,computerSymbol)\n            this.setState({turn: 'player'})\n            break;\n          case 2:\n            // defend column 2\n            if(grid[1]==='') this.playMove(1,computerSymbol)\n            else if(grid[4]==='') this.playMove(4,computerSymbol)\n            else if(grid[7]==='') this.playMove(7,computerSymbol)\n            this.setState({turn: 'player'})\n            break;\n          case 3:\n            // defend column 3\n            if(grid[2]==='') this.playMove(2,computerSymbol)\n            else if(grid[5]==='') this.playMove(5,computerSymbol)\n            else if(grid[8]==='') this.playMove(8,computerSymbol)\n            this.setState({turn: 'player'})\n            break;\n          default: break;\n        }\n      }\n\n      // defend rows\n      else if(this.rowToDefend()) {\n        switch(this.rowToDefend()) {\n          case 1:\n            // defend row 1\n            if(grid[0]==='') this.playMove(0,computerSymbol)\n            else if(grid[1]==='') this.playMove(1,computerSymbol)\n            else if(grid[2]==='') this.playMove(2,computerSymbol)\n            this.setState({turn: 'player'})\n            break;\n          case 2:\n            // defend row 2\n            if(grid[3]==='') this.playMove(3,computerSymbol)\n            else if(grid[4]==='') this.playMove(4,computerSymbol)\n            else if(grid[5]==='') this.playMove(5,computerSymbol)\n            this.setState({turn: 'player'})\n            break;\n          case 3:\n            // defend row 3\n            if(grid[6]==='') this.playMove(6,computerSymbol)\n            else if(grid[7]==='') this.playMove(7,computerSymbol)\n            else if(grid[8]==='') this.playMove(8,computerSymbol)\n            this.setState({turn: 'player'})\n            break;\n          default: break;\n        }\n      }\n\n      else if(this.leftDiagToDefend()) {\n        console.log(\"Defend left diagonal!\")\n        if(grid[0]==='') this.playMove(0,computerSymbol)\n        else if(grid[4]==='') this.playMove(4,computerSymbol)\n        else if(grid[8]==='') this.playMove(8,computerSymbol)\n        this.setState({turn: 'player'})\n      }\n\n      else if(this.rightDiagToDefend()) {\n        console.log(\"Defend right diagonal!\")\n        if(grid[2]==='') this.playMove(2,computerSymbol)\n        else if(grid[4]==='') this.playMove(4,computerSymbol)\n        else if(grid[6]==='') this.playMove(6,computerSymbol)\n        this.setState({turn: 'player'})\n      }\n      \n      // random move\n      else {\n        const moves = this.possibleMoves()\n        const chosenMove = moves[Math.floor(Math.random()*moves.length)]\n        this.playMove(chosenMove, computerSymbol)\n        this.setState({turn: 'player'})\n      }\n\n      \n    // }) // end sleep\n\n    //console.log(this.positionsTaken(this.state.playerSymbol));\n    // this.sleep(300).then(() => {\n    //   console.log(this.positionsTaken(this.state.playerSymbol).concat(this.positionsTaken(computerSymbol)))\n    // })\n    \n\n    console.log('computer played a move');\n    this.setState({turn: 'player'})\n  }\n\n  render() {\n\n    return (\n      <div className=\"App\">\n        <div className='header'>\n          <h1>Tic Tac Toe</h1>\n        </div>\n        \n        <div className='grid'>\n          {this.state.grid.map((item,i) => {\n            return (\n              <div\n                key={i}\n                className='cell'\n                onClick={() => this.cellClicked(i)}\n              >\n                {item}\n              </div>\n            )\n          })}\n        </div>\n\n        <div className='footer'>\n          <p>Designed and built by Nathan Brown</p>\n          <p>{this.state.turn}'s turn...</p>\n          {this.state.gameOver ? <p>GAME OVER!</p>: <p></p> }\n        </div>\n      </div>\n    );\n  }\n}\n\nexport default Game;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}